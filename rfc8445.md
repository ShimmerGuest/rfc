Interactive Connectivity Establishment (ICE):A Protocol for Network Address Translator (NAT) Traversal

# 简介
这个文档用于描述一种基于UDP通信的协议用于穿越Network Address Translator（NAT）。这个协议叫做Interactive Connectivity Establishment（ICE）。ICE使用Session Traversal Utilities for NAT (STUN)和它的扩展Traversal Using Relay NAT (TURN)。
这个文档继承RFC 5245。
# 介绍
通常和对端建立会话涉及到IP和ports交换用于确认数据源和传输。然而，这种操作需要穿越Network Address Translators（NAT）。这个协议寻求直接在参与者之间创建数据通道，不以来其他应用做中介。这么做是为了减少数据延迟，减少数据丢失和减少转发程序部署的费用。然而穿越NAT是一件困难的事。
我们定义了许多的解决办法来允许这些协议穿越NAT。它们包括Application Layer Gateways（应用层网关），Middlebox Control Protocol[RFC3303]，original Simple Traversal of UDP Through NAT (STUN) 规范[RFC3489]，和Realm Specific IP[RFC3102] [RFC3103] 需要和会话描述扩展一起使用才能工作，例如Session Description Protocol（SDP）attribute [RFC4566] 用于实时控制协议(RTCP)[RFC3605]。不幸的是，这些技术在不同的网络拓扑中有不同的优劣。所以管理这和实现者需要决定哪种解决方法去解决它们可能会遇到的网络拓扑。这将导致你的系统变得复杂和脆弱。
这个规范定义了Interactive Connectivity Establishment(ICE)基于UDP用于穿越NAT（即使ICE也被扩展用于其它的协议，例如tcp[RFC6544]）。ICE会交换许多的IP地址和端口，用于测试连通性和端到端的连通性检查。IP和端口交换使用ICE-usage-specific(ICE使用规范)语法（在Offer/Answer交换），通过stun[RFC5389]做connectivity checks(连通性检测)。ICE同时也适用Traversal Using Relay around NAT（TURN）[RFC5766]做连通性检查，一种STUN的扩展。ICE交换多个IP地址和端口，也允许选择多宿主和双栈主机。因为这个原因，RFC5245启用之前在RFC4091和RFC4092定义的解决方案.
附录B提供了设计ICE相关的背景信息和动机。
# ICE的概述
在一般的ICE架构中，有两端需要建立通信。注意ICE没有设计信令协议，你需要通过别的途径。ICE假定你能在两端之间建立一个信令通信机制。
在一开始，agents（表示其中一端，后面不做而外说明）不清楚自己的网络拓扑。agents不清楚自己是否在一台NAT后面（也有可能是多台）。ICE允许agents通过足够的拓扑信息去发现一条或者多条路径用于和对端传输信息的会话。
图形1显示了一般的ICE架构。agents是标签L和R。L和R分别在自己的NAT后面，尽管它们自己并不清楚这个事情。L和R有能力通过信令服务交换互相的candidate，candidate用于双方建立会话。
除了agents，signaling server（信令服务），和NATs，ICE通常会使用STUN和TURN服务。每个agent可以有自己的STUN和TURN服务。

                               +---------+
             +--------+        |Signaling|         +--------+
             | STUN   |        |Server   |         | STUN   |
             | Server |        +---------+         | Server |
             +--------+       /           \        +--------+
                             /             \
                            /               \
                           / <- Signaling -> \
                          /                   \
                   +--------+               +--------+
                   |  NAT   |               |  NAT   |
                   +--------+               +--------+
                      /                             \
                     /                               \
                 +-------+                       +-------+
                 | Agent |                       | Agent |
                 |   L   |                       |   R   |
                 +-------+                       +-------+

                     Figure 1: ICE 架构设想
ICE基础的看法如下：每个agent有许多传输地址（IP地址，端口和特定协议的组合，在这个规范中我们一直使用UDP），他可以用于和对端通信。它们可能包含如下：
- 传输地址能直接通过网络接口获取（这种一般都是指的本地网卡地址，可以直接获取）
- 已经被公网NAT转换的地址（server-reflexive地址）
- 在TURN服务上申请的转发地址(relayed address)
理论上，L的任何一个候选地址都有可能可以和R的任何一个候选地址进行通信。在实践中，许多候选地址之间的组合是不能通信的。例如，如果L和R都在NAT后面，那么它们通过接口直接获取的地址是不可能直接通信（毕竟！！！这就是为什么需要ICE）。ICE的目的就是去发现哪些组合能进行通信。ICE会通过某种规则尝试所有可能的组合（按照一定的顺序），直到发现一个或多个能使用的组合。

## 收集Candidates
为了执行ICE，ICE agent需要辨别和收集候选地址。一个Candidate带有一个transport address（ip地址，端口，协议的组合。在这里协议我们只使用UDP）。candidates具有不同的类型，一些是直接从硬件或者网络接口中获取，一些是通过STUN和TURN服务发现的。
第一类Candidate的transport address是可以直接通过本地接口获取。这种Candidate叫做“host candidate”。本地获取地址接口可能是Ethernet或者Wi-Fi，或者是VPN（Virual Private Network），MIP（Mobile IP）。在所有这些情况下，这样的接口都是一个本地接口，可以从中分配端口。
下一类，agent使用STUN或者TURN去绑定额外的Candidate。下面两种情况：经过NAT转换的地址和从TRUN服务中申请的地址。在我们使用了TURN服务情况下，两种地址都可以通过TURN服务获取。如果我们只使用了STURN服务，我们只可以从STURN获取server-relexive candidate。这两种candidate和host candidate的关系如图示2。在图中，两种类型都是通过TURN服务发现的。在图中，X:x意味着IP地址X和UDP端口x。
                      To Internet

                          |
                          |
                          |  /------------  Relayed
                      Y:y | /               Address
                      +--------+
                      |        |
                      |  TURN  |
                      | Server |
                      |        |
                      +--------+
                          |
                          |
                          | /------------  Server
                   X1':x1'|/               Reflexive
                    +------------+         Address
                    |    NAT     |
                    +------------+
                          |
                          | /------------  Local
                      X:x |/               Address
                      +--------+
                      |        |
                      | Agent  |
                      |        |
                      +--------+


                     Figure 2: Candidate 关系
当agent从IP地址和端口X:x发送一个TURN Allocate 请求，那么NAT（假定只有一个）会创建一个绑定X1':x1'，host candidate和server-reflexive candidate之间映射。从host candidate发送出去的包经过NAT的转换会被变成从server-reflexive candidate发送出去的包。发送到server-reflexive candidate的包经过NAT会发送到host candidate，NAT会转发到agent。host candidate和server-reflexive之间的关系称之为“base”。
注意：“Base”意思是一个特定的candidate地址，因此，对于host candidate来说，“Base”就是它自己。
当agent和TURN服务中间有许多的NATs，TURN请求会在每个NAT上创建一个绑定，但只有最外面的server-reflexive candidate（距离TURN服务最近的）会被agent发现。如果agent没有在NAT后面，server-reflexive candidate会和base candidate一样，这种情况下server-reflexive是多余的，并且会被清楚。
当Allocate请求到达TURN服务。TURN服务会从Y地址申请一个端口y，并且生成一个Allocate响应，告诉agent相关的relay candidate。并且TURN服务会告诉angent server-reflexive candidate，X1':x1'，拷贝Allocate请求中源的地址。TURN作为L和R的包转发服务，转发它们的流量。为了发送数据到L，R发送数据到TURN服务的Y:y，然后TURN服务转发到X1':x1'，NAT中X1':x1'映射到X:x，并且会把数据发送给L。
当只有STUN服务被使用的时候，agent发送STUN Binding请求到STUN服务。STUN服务会通过Binding响应告诉agent它的server-reflexive candate X1':x1'，过复制Binding请求的地址到Binding响应中。

## Connectivity Checks（连通性检查）
一旦L已经收集完毕所有的Candidates，他会通过从高到低的优先级对它们进行排序，并且通过信令通道将它们发送到R。当R从L中收到所有的candidates，他也会进行同样的流程收集排序，并且响应L它自己的Candidate列表。最后，每一个ICE agent有自己和对端完整的列表。后面会将他们配对起来，产生candidate pairs。为了检查哪一个pairs有效，agent会有序的执行每一个Connectivity checks（连通性检查）。每一个检查时一个STUN request/response任务，stun client会通过一个特殊的candidate pair通过发送一个STUN请求，从本地candidate发送到对端的candidate
connectivity checks基本的准则如下：
1. 通过优先级对candidate pairs排序
2. 通过优先级顺序发送检查
3. 响应对端发送的检查
在双方agents检查一个candidate pair，需要进行4次握手
                  L                        R
                  -                        -
                  STUN request ->             \  L's
                            <- STUN response  /  check

                             <- STUN request  \  R's
                  STUN response ->            /  check

                    Figure 3: 基础的连通性检查
值得注意的是，STUN请求发送和接收的地址和端口，我们会用相同地址和端口发送数据（例如RTP，RTCP或者别的协议）。因此，我们通过包的内容来分辨STUN数据或者是媒体数据，而不是通过端口来分辨。
因为STUN Binding请求被用于connectivity check，那么STUN Binding响应会包含agent通过公网NAT转换后的地址。如果这个transport address和之前收到的candidates不相同的话，代表这是一个新的candidates（peer-reflexivecandidate），我们需要和别的candidate一样对它进行连通性检查。
因为算法会搜索所有的candidate pairs，如果一个有效的pair出现，算法最终会找到它。为了更快更好的找到它，candidates被排序。candidate pairs排序后的列表称为“checklist”。
agent会定期的对checklist中下一个candidate pair发送一个STUN request。他们被称之为“ordinary checks”。当一个STUN事务成功了，一个或者多个candidate pairs会被称之为“valid pairs”，并且会被加入到candidate-pair列表中，这个列表称之为“valid list”。
为了更快解决检查，一旦R收到L的check message（STUN request），R会通过相同的Candidate pair发送一个connectivity-check消息到L。这个被称之为“triggered check”，为了加快找到valid pairs。
最后，L和R都知道它们发送后接收到端到端的消息。
通常来说，那个优先级算法会给相似的类型相似的优先级，直接路径（没有经过NAT或者relays）比间接路径（经过relays或者NAT）优先级高。在这个大纲下，angents的优先级算法有许多可以调整的空间。
一个数据流需要不同的components组合而成（每一份数据需要有他们自己的component，例如RTP和RTCP）。
## Nominating Candidate Pairs and Concluding ICE
ICE分配一个一个ICE angent作为controlling角色，另外一个座位controlled角色。controlling会为每一个data stream选出component，controlling 会从valid list中选出一个valid pair用于数据的传输。确却的时机取决于本地的规则。
当在选择中，controlling agent会让connectivity checks一直继续，直到每一个data stream都有与之对应的valid pair选出作为component，然后会通过这个valid pair发送STUN请求，附带上信息告诉controlled agent，这个valid pair被选中。如图示4。
             L                        R
             -                        -
             STUN request ->             \  L's
                       <- STUN response  /  check

                        <- STUN request  \  R's
             STUN response ->            /  check

             STUN request + attribute -> \  L's
                       <- STUN response  /  check

                           Figure 4: Nomination
一旦controlled agent接收到STUN带有选举信息的请求，它会标记自己相同的pair（除非之前已经标记过了）。如果以上的流程成功了，那么agents会标记被选中的pairs，并且会取消所有未来给对应的data stream选中的component。一旦agent给data stream设置了对应的component，那么对应的pair就是selected pairs。之后，只有selected pairs会发送和接收与之对应的data stream数据。
## ICE Restart
一旦ICE被中指，他可以被任何一个ICE agent重启。我们可以通过发送一个updated candidate信息，用来表示需要重启。
## Lite Implementations
这种情况下，其中一端的ICE agents会一直处于公网情况下，并且有一个公网IP地址，可以接受来自任何地方的通信。为了使这些agent更容易支持ICE，ICE定义了一种特殊的实现叫做“lite”（和full implemention有差异）。Lite agent的一端仅仅使用host candidates，它不会自己生成connectivity checks或者有状态机（agent在接受不同的消息会有不同的状态转换），但是他们需要对connectivity checks请求做出响应。
## ICE Usage
这块说明我们一般在ICE agents中交换candidate信息的协议。不同协议详情的信（怎么表示candidate信息，具体的交换流程）在别的单独文档中。
一种允许agents交换candidate信息的方法是Offer/Answer([RFC3264])，作为SIP协议中的一部分[RFC3261]。
[RFC7825]定义了RTSP协议也可以用于ICE信息的交互。
# Terminology
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here. Readers need to be familiar with the terminology defined in [RFC5389] and NAT Behavioral requirements for UDP [RFC4787].
这段主要是一个RFC文档关键字的申明。
接下来是和ICE相关的术语：
ICE Session：ICE session由所有ICE相关的动作组合而成，一开始的candidate的收集，双端之间的交互（candidate 交换，连通性检查，选举，保活），最后所有candidate的释放，或者是ICE restart。
ICE Agent，Agent：ICE agent（有些时候也叫“agent”）是协议的实现涉及到ICE candidate交换。一般candidate 交换，涉及到两个agent。
Initiating Peer，Initiating Agent，Initiator：一个initiating agent是一个ICE agent初始化ICE candidate交换流程。
Responding Peer，Responding Agent，Responder：responding agent是一个ICE angent，它产生在接受并且响应candidate信息交换过程。
ICE Candidate Exchange，Candidate Exchange：这个流程是ICE agents交换用于执行ice流程的信息（candidates和passwords）。SDP使用的Offer/Answer可以用于交换candidate信息。
Peer：在ICE的会话中，从一个ICE agent的角度出发，另外一个agent就是peer。特殊的，从initiating agent角度来看，peer就是responding agent。从responding agent角度来看，peer就是initiating agent。
Transport Address：IP地址和传输协议端口（udp，tcp）的组合。
Data,Data Stream,Data Session：当ICE被用于建立data sessions，数据也会通过相同的协议传输。媒体数据一般基于RTP传输，组装成RTP的流传输。Data Session用于双端交换数据，这条链路是通过ICE创建和测试的。
Candidate，Candidate Information：一个Transport address是一个数据的潜在接收点。Candidate也是有属性的，例如类型，优先级，foundation（这个不太清楚是啥）和base。
Component：data stream是有许多component共同组成的。一个data stream需要许多的component，每一个component都有序的工作组成整体的data stream。例如RTP/RTCP的data stream，他们每个data stream就是一个components，分别用于传输rtp和rtcp，当然如果是RTP和RTCP是复用个通道的话，那么就只有一个component。一个component又一个独立的candidate pair，这个candidate pair不会被别的component使用。
Host Candidate：这个Candidate绑定一个特殊的端口和IP。这个IP地址直接通过物理接口或者是逻辑接口（VPN）获取。
Server-Reflexive Candidate：这个candidate的IP地址和端口是经过NAT转换后，通过请求STUN服务获取到的地址。
Peer-Reflexive Candidate：这个candidate的IP地址和端口经过NAT转换后，但是和Server-Reflexive Candidate不同的是，这个地址是通过peer发现的。
Relayed Candidate：这个candidate是和relay server绑定的，例如TURN服务。
Base：ICE agent发送的特定的candidate的transport address。对于host，server-refleiv和peer-reflexive candidate来说，base 就是host candidate。对于relayed candidate来说，base就是relayed candidate。
Related Address and Port：一个Transport address相关的candidate，被用于诊断或者其他目的。如果一个candidate是通过server或者peer获取的（server-reflexive，peer-reflexive），与之对应的address和port就是与之对应server或者peer-reflexive的base。如果candidate是relayed，那么与之对应的地址就是经过映射后的relayed。如果是host candidate，那与之对应的就是host candidate。
Foundation：一个任意的字符串，用于冻结算法（freezing algorithm）对相似candidate分组。如果两个candidate有相同的type，base IP address，protocol，和STUN，TURN服务，那么它们的Foundation也是相同的。如果有任何不同，那么Foundation也不相同。
Local Candidate：ICE agent绑定或者发送出去的candidate。
Remote Candidate：ICE agent接收自对端的candidate。
Default Destination/Candidate：component的default destination可以被ice agent使用的，但不是ice自己发现的。component中的default candidate是和default destination匹配的transport address。
Candidate Pair：包含本地的candidate和远端的candidate。
Check，Connectivity Check，STUN Check：为了验证连通性的STUN Binding请求。从本地的candidate发送到远端的candidate
Checklist：一个排序的set









